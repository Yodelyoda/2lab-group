using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _2lab_group_v1
{
    class Program
    {
        static void Main(string[] args)
        {
            //Оператор рівності «==»
            //За замовчуванням при роботі з посилальними типами даних(всі класи крім string, інтерфейси, делегати) 
            //оператор «==» перевіряє рівність посилань.Він повертає true, коли обидва посилання вказують на один об'єкт, в іншому випадку - false.

            //Метод Equals приймає один аргумент - об'єкт, який буде порівнюватися з поточним об'єктом, і визначає, чи рівні між собою ці об'єкти.
            //Цей метод віртуальний, і його базова реалізація це просто перевірка рівності посилань оператором «==». 
            //Але коли ми створюємо якийсь клас, і нам необхідно реалізувати можливість перевірки ідентичності об'єктів, слід перевизначити саме даний метод,
            //а не скористатися перевантаженням оператора «==», щоб не плутати базові призначення цих інструментів порівнювання.

            Circle m1 = new Circle(2, 5, 10);

            Circle m2 = new Circle(2, 5, 10);

            Circle m3 = new Circle(10, 10, 20);

            Circle m4 = m1;

            Console.WriteLine(m1.Equals(m2)); // true

            Console.WriteLine(m1.Equals(m3)); // false

            Console.WriteLine(m1 == m2); // false

            Console.WriteLine(m1 == m4); // true

            //Як бачимо, в коді вище метод Equals і оператор «==» працюють відповідно до своїх базових визначень.
            //Також для підвищення продуктивності при перевизначенні методу Equals
            //рекомендується перевантажувати його реалізацією з типом аргументу відповідного класу, в якому він первизначається:
            //public bool Equals (Circle obj) { ......... } "рядки з 44 по 54 в класі"


            Console.WriteLine(m1.GetHashCode()); // 10 = r

            Console.WriteLine(m2.GetHashCode()); // 10 = r

            Console.WriteLine(m3.GetHashCode()); // 21 = r + 1

            Console.WriteLine(m4.GetHashCode()); // 10 = r

            //Даний метод, як випливає з його назви, повертає хеш-код. 
            //Хеш -код це число відповідає значенню об'єкта. 
            //Це число ми отримуємо в результаті роботи деякого методу, який повинен мати наступні властивості:
            //- Він повинен повертати однаковий хеш-код кожного разу при виклику для одного і того ж об'єкта.
            //- Якщо є два рівних (еквівалентних) об'єкта, то хеш-код для них повинен бути однаковим. Тільки це не 
            //означає, що якщо об'єкти нерівні, то їх хеш-коди обов'язково будуть різними.
            //Метод GetHashCode використовується в таких структурах, як хеш - таблиці(Hashtable)
            //Методи Equals і GetHashCode тісно пов'язані між собою, при перевизначенні одного з них, слід перевизначати і інший.

            //Для чого використовуємо методи Equals і GetHashCode
            //1-При реалізації типу значення рекомендується перевизначити метод Equals. 
            //1-При цьому забезпечується підвищена продуктивність порівняно з реалізацією методу Equals за замовчуванням для ValueType.
            //2-При реалізації посилочного типу рекомендується перевизначити метод Equals, якщо ваш тип виглядає як базовий, наприклад Point, String, BigNumber і т.д.
            //3-Перевизначаємо метод GetHashCode, щоб тип правильно працював у хеш-таблиці.
            Console.ReadLine();
        }
    }
}
